# python网络编程(2)：UDP

IP协议只负责将每个数据包传输至正确的机器，如果两个独立的应用程序要维护一个会话的话，那么还需要两个额外的特性。

- 需要为两台主机间传送的大量数据包打上标签，这样就可以将表示网页的数据包和利用电子邮件的数据包分开来，而这两种数据包也可以与该机器正在进行的其他网络会话使用的数据包分开。这一过程叫多路复用（multiplexing）。
- 对两台主机间的独立传输的数据包发生的任何错误都需要进行修复。而丢失的数据包也需要进行重传，直到将其成功发送至目的地址。另外，如果数据包到达时顺序错乱，则要将这些数据包重组会正确的顺序。最后要丢弃重复的数据包，以保证数据流中的信息没有冗余。提供这些保证的特性叫做可靠性传输（reliable transport）。

用户数据报协议（UDP）只解决了上述第一个问题。提供一个端口号，用于对目标为同一机器上的不同服务的多个数据包进行适当的多路分解。虽然支持多路复用和分解，但是使用UDP协议的网络仍然需要自己处理丢包、重包和包的乱序问题。

传输控制协议（TCP）解决上面两个问题。它跟UDP一样，使用端口号来支持多路复用和分解。除此之外，TCP还保证了数据流的书序及可靠性传输。

我们不太可能在自己的任何一个应用程序中使用UDP。

### 1.端口号

端口是无符号16位数字，端口号范围从0到65536。源端口(source port)标识了源机器上发送数据包的特定进程或程序，而目标端口（destination port）则标识了目标IP地址上进行该会话的特定应用程序。

```
Source(IP: port number) → Destination(IP: port number)
```

发送方需要在数据包中带有目标IP和端口号，但是客户端可以没有显示声明自己的请求端口号，返回响应时如果请求方没有端口号则操作系统会随机分配一个端口号。

客户端获取需要连接的端口号方法：

惯例：互联网号码分配机构（IANA）为需要专用服务分配了官方的知名端口号。0-1023，例如DNS默认端口号为53.

自动配置：通常情况下，计算机首次连接网络时，会使用DHCP这样的协议来获取一些重要服务的IP地址，比如DNS。应用程序通过将这些IP地址和知名端口号结合，便可访问这些基础服务。

手动配置：除了上述两种情况外，管理员或用户还必须手动配置IP地址或相应的服务域名。从这一意义上来说，每当网络浏览器中键入服务器名时，实际上都发生了手动配置的对应操作。

#### 端口号分类

知名端口（0-1023）

注册端口（1024-49151）在操作系统层上并无任何特别之处。然而IANA可以为一些专用服务注册这些端口。因此IANA建议，只在使用其指定服务时才使用这些端口。

其余的端口号（49152-65535）都可以随意使用，当客户单无需为其提供的服务指定端口号时，现代操作系统便会从这些端口号组成的端口池中随机选取端口号用于该服务。

查询域名的端口号

```python
>>> import socket
>>> socket.getservbyname('domain')
53
```

在Linux和macOS中，知名服务名与其对应的端口号通常保存在/etc/services文件中。

### 2.套接字

套接字（socket）是一个通信端点，操作系统使用整数来标识套接字，而python则使用socket.socket对象来更方便的表示套接字。该对象内部维护了操作熊标识套接字的整数（可以调用fileno()方法来查看）。每当调用socket.socket对象的方法请求使用该套接字的系统调用时，该对象都会自动使用内部维护的套接字整数标识符。

```python
>>> import socket
>>> sock = socket.socket()
>>> sock.fileno()
628
```

socket是操作系统中I/O系统的延伸部分，它可以使进程和机器之间的通信称为可能。

socket最早起源于BSD UNIX类的操作系统。在Linux系统下，一切皆文件。既然一切都抽象成了文件，那么对于打开一个的文件，应用程序如何对应上呢？文件描述符应运而生。

文件描述符简称fd，当应用程序请求内核打开/新建一个文件时，内核会返回一个文件描述符用于对应这个打开/新建的文件，其fd本质上是一个非负整数，读写文件也需要使用这个文件描述符来指定待读写的文件。（文件描述符可以再好好研究下）

在UNIX系统上，比如BSD，有一些现有的、和文件描述符一起工作的系统调用，其中包括open()、read()、write()和close()。

当把对网络的支持加入操作系统时，是以一种扩展现有文件描述符结构的方法来实现的（套接字也是文件）。新的系统调用被加入并和socket一起工作。现有的很多系统调用同样能和socket一起工作。

在某些方面，socket可以被看成一个标准的文件描述符。在UNIX类平台上，read()、write()、dup()、dup2()和close()这样的系统调用会像为标准文件描述符那样为socket工作。很多时候，程序并不需要知道它正在把数据写入一个文件、终端或是一个TCP连接。

socket和普通文件的不同：

- 建立方法：很多文件是通过open()函数来打开的，socket是通过socket()函数来建立的，并且还需要另外的调用来激活他们。
- socket的recv()和send()这两个系统调用和read()和write()极为相似，send()和recv()调用提供了socket额外特有的功能。

#### 建立套接字

对于一个客户端程序来说，建立一个socket套接字需要两个步骤，首先需要建立一个实际的socket对象，其次需要把它连接到远程服务器上。创建套接字对象语法：

```
socket.socket([family[, type[, proto]]])
```

##### 参数：

- family表示协议家族，一般是AF_INET(用于Internet进程间通信，对应IPv4)和AF_UNIX(用于同一台机器进程间通信)，常用的是前者。
- type表示套接字类型，SOCK_STREAM(流式套接字，用于TCP协议)或SOCK_DGRAM(数据报套接字，主要用于UDP协议),注意，数据报(datagram)[不是数据包(packet)]是用来表示应用层数据块传输的官方术语。

##### 注意：

- TCP发送数据时，已经建立好TCP连接，所以不需要指定地址，UDP是面向无连接的，每次发送都要指定发送给谁。
- 服务端与客户端不能直接发送列表、元组、字典。需要字符串化(repr(data))

对于TCP通信，建立一个socket连接：

```python
import socket   #导入socket

print('Creating socket...')
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  #创建socket套接字对象
print('done.')

print('Connecting to remote host...')
# s.connect() 主动初始化TCP连接，一般address格式为元组(hostname, port),如果连接出错，返回socket.error错误。
s.connect(('www.baidu.com', 80))
print('done.')
```

**注意：C语言的connect()函数需要远程主机的IP地址，在python中，socket对象的connect()函数会根据需要利用DNS把域名自动转换为IP地址。但是对端口号则不是这样。**